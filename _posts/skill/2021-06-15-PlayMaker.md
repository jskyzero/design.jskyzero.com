---
layout: post
title: PlayerMaker与关卡脚本
featured-img: besiege
mathjax: true
categories: [Unity, Summary]
---

制作关卡离不开脚本逻辑的组合，本文将以PlayeMaker为切入点谈谈脚本与关卡制作。

<!--more-->


# PlayerMaker与关卡脚本
`jskyzero` `2021/05/25`


## 工具的必要性

为什么我们需要一个工具来组织逻辑？

使用C#作为描述语言，借助UNITY引擎内部的MonoBehavior的“生命周期”逻辑，可以原生的访问所有接口，C#作为一门面向对象的高级编程语言的表达能力、架构能力。使用编程语言的调试灵活度，似乎可以作为默认的、同时也是极其强大的解决方案。

同样的，PlayMaker可以用来组织条件和逻辑操作，也是是逻辑的一种组织方式。

{% mermaid %}
graph LR;
    A[解决方案] -->|包括| B(C# 编写逻辑代码);
    A[解决方案] -->|包括| B1(PlayMaker 编写状态跳转);
{% endmermaid %}

{% mermaid %}
graph LR;
    C{如何评价一种解决方案};
    C -->D[表达能力强];
    D -->D1["接口丰富，可自定义"];
    D -->D2["逻辑组合流转，自由度高"];
    D -->D3["变量，支持使用变量"];
    D -->D4["逻辑条件完备"];
{% endmermaid %}

{% mermaid %}
graph LR;
    C{如何评价一种解决方案};
    C -->E[易维护];
    E -->E1[可读性];
    E -->E2[易学习];
    E -->E0[可复用];
    E -->E3[调试容易];
    E -->E4["易修改，修改可控"];
{% endmermaid %}

{% mermaid %}
graph LR;
    C{如何评价一种解决方案};
    C -->F[设计优雅];
    F -->F1[数理逻辑模型];
    F -->F2[脚本生命周期];
{% endmermaid %}

与C#编写逻辑代码相比，PlayMaker突出的优点

+ 学习成本低：可视化，无需了解编程知识。
+ 可读性好：脱离于代码以外，状态一目了然。
+ 复用性好：无需额外的架构抽象

此外，上面提到的诸多场景也都有对应的一些功能和特性，如支持变量、有丰富的已有库等。

PlayMaker的局限性：

+ 状态机的局限性：
  + 包括复杂度提高以后的易读、修改成本
  + 状态机本身表达能力


## PlayMaker概览

接下里我们具体讨论一下PlayMaker的相关逻辑。

一个例子：

{% mermaid %}
graph TD;
    A[灯是灭的] -->|开灯| B[灯是亮的];
    B -->|关灯| A;

    A1[灯是灭的] -->|包含| D(开灯动作);
    D --> |执行完| D1(关灯完成事件);
    
    B1[灯是亮的]-->|包含| E(关灯动作);
    E --> |执行完| E1(关灯完成事件);
{% endmermaid %}

例子中我们可以看到：

+ 使用状态作为基本组织单位，使用状态机的跳转组织逻辑
  + 状态中包含脚本操作
  + 脚本操作（或者外界行为）触发事件
  + 事件触发状态的跳转

<!-- ### 教程：灯的开关

+ 状态
+ 事件
+ 状态机的跳转
+ 操作：GUI组件（点击）
+ 事件


### 教程：宝箱的开关

+ 过渡状态
+ 操作：动画播放

### 教程：触发器

+ 触发器
+ 触发器脚本，事件
+ 操作：GUI TEXT

### 尝试：自定义脚本

+ 模板
+ 注释 -->


## 关卡与脚本抽象

先鸽了
