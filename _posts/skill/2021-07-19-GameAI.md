---
layout: post
title: AI行为树：从入门到精通
featured-img: death_stranding
mathjax: true
categories: [AI, Summary]
---

# AI行为树：从入门到精通

[![](https://img.shields.io/badge/游戏AI-blue.svg?style=flat)]()
[![](https://img.shields.io/badge/行为树-blue.svg?style=flat)]()
[![](https://img.shields.io/badge/作者-jskyzero-brightgreen.svg?style=flat)]()
[![](https://img.shields.io/badge/日期-2021/07/16-brightgreen.svg?style=flat)]()


本文介绍游戏AI与行为树的一些知识。本文希望做到：更加系统、与工具无关、附带练习。

本文中可能存在疏漏错误，或是夹杂了作者的主观观点，欢迎指正讨论。

[TOC]


## 游戏AI介绍

> 游戏AI做，也只做一件事：那就是为玩家提供好的体验[^1]。

“好的体验”并不是一个很好定义的概念，广义上的AI也是。学术上的AI，多是在研究一些诸如固定情形下成功概率最大的行为的课题，而影视界的AI，可能是一些虚拟但是从心底里让人感到真实的虚拟角色。

本文接下来讨论的AI是游戏AI，从特征上讲，游戏AI更加接近影视界的AI，两者同样专注于提供一些真实的行为、以假乱真的体验。中间或许可能会用到学术AI的算法和思想，但是会比学术AI更加有血有肉。

![image-20210719191304929]({{site.img_url}}/skill/AI行为树：从入门到精通.assets/image-20210719191304929.png)

游戏AI受限于游戏类型、想要营造的体验，具体行为差异很大，用到的技术手段、算法也大有不同，总的来看，我们可以关注以下游戏AI的特征：


[^1]: 引用自《Game AI Pro》，后文部分知识同样出自本书。


### 部分特征

+ 作者控制：AI的修改权，衡量是否方便修改AI各种情况下的行为的能力。
+ 反应性：AI是否能针对特定情形采取不一样的行为。
+ 随机性：面对相同情形，AI采取的行为是否固定。

以作者控制为例，古典的游戏AI的逻辑是确定的，而近些年兴起的采用深度学习算法训练出的AI则是会根据训练集和评估方式产生变化的，你该如何对一个机器学习的模型表达出：”酷“、”傻大个“之类的概念呢，这种按照设计修改AI的能力就是作者控制。

我们可以按照作者控制给一些AI技术排一个序：

![image-20210719191923675]({{site.img_url}}/skill/AI行为树：从入门到精通.assets/image-20210719191923675.png)

反应性和随机性，可以丰富AI体验，两者并不互斥，甚至可以结合起来。

这三者可能会根据游戏类型有着不同的倾向，也并不是“多就一定好”。

> 思考-1：如何给机器学习的模型表达出：”酷“、”傻大个“之类的概念？


### 行为树历史概述

行为树是一种在游戏开发中广泛使用的AI技术，最早使用的主流游戏是《光环2》。行为树是分层状态机、调度、计划、与动作执行等AI技术的集合。

行为树最主要的优势是容易理解并且可以使用图形化编辑器。

你可能会敏锐的注意到，上面的AI技术排序中，并没有行为树，那是因为行为树的特性，很大程度上取决于行为树所使用的节点。后面我们会具体就行为树的特性展开叙述。

![image-20210719193910321]({{site.img_url}}/skill/AI行为树：从入门到精通.assets/image-20210719193910321.png)


### 与有限状态机的对比

AI领域另一个常见的技术是有限状态机，可能会问的一个是问题是：两种技术各自适用的场景是什么？一般来说，行为树适用于AI，而有限状态机适用于其他的图形化逻辑，当然，两者可以互换，但是这不是这两个工具本来的设计意图。

对于一部分人来说，AI领域的有限状态机的时代已经结束了，这里不会继续深入叙述，但是行为树对比状态机确实有一定的优点。

+ 灵活：比如支持并行、方便行为互斥。

+ 不同的强大：在规模复杂以后，连线混乱的有限状态机。

+ 容易修改：只修改父层连线


## 行为树基础概念

> 本节我们会具体行为树的具体概念，我们会从底层开始，逐步解释行为树的构成、执行逻辑。


### 数据模型

故名思意，行为树采用树形数据结构储存数据，更准确的说，是有序树，因为显然，行为树对节点的顺序关系敏感（很多情况下有序的行为才有意义）。

![image-20210719195438566]({{site.img_url}}/skill/AI行为树：从入门到精通.assets/image-20210719195438566.png)


### 节点类型

从节点是否可以连接子节点出发，我们可以把节点分为

+ 叶子节点：不允许有子节点

+ 父亲节点：允许有子节点

按照用途，叶子节点可以更加细分的分为：

+ 条件节点：判断某一个条件，比如检测范围、检测属性、检测状态。
+ 动作节点：执行某一个具体的行为，比如移动、设置属性、播放动作。

条件节点听起来就是会得到一个检测的结果，实际上，动作节点也有类似条件节点的“结果”，这里结果的意义可以是代表节点是否成功执行。

而且这些结果也就会用在下面这两种父亲节点上：

+ 组合节点：储存一系列子节点，按照一定逻辑执行。比如与节点、或节点。
+ 装饰节点：只能有一个子节点，修饰子节点的行为。比如非节点。

![image-20210719195934059]({{site.img_url}}/skill/AI行为树：从入门到精通.assets/image-20210719195934059.png)

学过逻辑学我们会知道，与或非等基础逻辑行为，比如与是当参与运算的都为真才返回真。非是对结果取反。我们知道，这三者已经有很强的逻辑表达能力了。下面我们给出一个例子：

以下施工中

组合节点最常见的有：

+ 与节点：或者说顺序节点

n  会先逐个执行子节点，当有一个返回不为**Success**，则停止后续执行，返回**Failure**

n  全部为**Success**，返回**Success**。

n  多用于一些前面条件不满足，后续行为失去意义的场合。

+ 或节点：或者说选择节点

n  会先逐个执行子节点，当有一个返回为**Success**，则停止后续执行，返回**Success**

n  全部为**Failure**，返回**Failure**。

n  多用于一些并行行为的挑选的情况。

装饰节点最常见的有：

+ 非：对执行结果进行取反。

+ 返回成功：返回**Success**。

+ 返回失败：返回**Failure**。


以上基础逻辑行为节点组合，有很强的“表达”能力，同时有命题逻辑等价逻辑（德摩根定律），可以根据实际情况灵活组合，更多具体例子会在后文给到。


### 执行逻辑

以上节点的组合，成功完成了行为的组织，深入的另一个问题是这些节点具体如何执行，为了更加彻底的理解行为树，我们还需要了解行为树的执行行为。


实际上，就像状态机中角色每一帧一定会处于某个状态，行为树AI每一帧都会执行这些行为。是的，每一帧。你可能会敏感的在意到性能问题，后文会具体讨论，现在先让我们进行一个简单情况的假设，每个节点的性能很高，在一帧内，可以完成大量节点的执行。


执行某个节点：

​       当前节点是否是父亲节点

​              循环：是否有子节点可以执行

​                     执行子节点

​       当前节点的实际执行

​

简单的伪代码如上，简单理解而言，是一个深度优先遍历，执行会先下后上，先左后右。


引申：简单情况下的并行的与、或节点的讨论：

对于与、或节点，短路行为是通过“是否有子节点可以执行”的判断完成的，对于简单情况下的并行与、或节点，会完成所有子节点的执行，而在当前节点的实际执行中，进行包含短路的判断，即：结果维持一致，但是被短路的节点会被执行。


### RUNNING与打断

以下我们开始讨论是实际的情况，事情会一下子变得复杂起来。


并不是所有动作都可以在一帧内完成，为此，在除了**Success**和**Failure**之外，引入了**Running**状态（或者理解为“执行结果”）。


对于**Running**状态的节点，下次行为树执行时候会继续执行该节点，直到完成**Running**状态，返回非**Running**执行结果（比如**Success**和**Failure**），此时将继续执行该行为树。

​

在实际实现上，为了保证继续执行特定节点的目的，同时兼顾性能，会避免遍历，采用储存**Running**状态的节点的方式，执行出结果后，会采用逆向遍历的方式。同时，对于复合节点，会存储当前执行的子节点个数。（留意这一点。）


引申：**Running**情况下的并行的与、或节点的讨论：

在第一个**Running**状态完成计算后，逆向遍历执行的时，将有机会对其他节点进行执行，如果后续都是简单情况，则仍然会在当前节点的实际执行中，进行含短路的逻辑判断，如果后续仍有**Running**状态的节点，要小心**Running**状态可能会被短路，对于整个并行与、或节点将可能返回确定的值。


对于一些完成**Running**节点执行后，后续节点不需要执行的情况，引入了打断状态，目前打断状态分为：


+ **TopInterrupt**：顶层打断，向上传递，整棵行为树后续节点都会放弃执行。

+ **SuccessInterrupt**：成功打断（分层），打断本层后续节点，向上传递，直到向上被父亲节点处理为成功（通查情况）。

+ **FailureInterrupt**：失败打断（分层），同成功打断，但是会被处理为失败（通查情况）。

​

注意，打断绝大部分情况都是配合**Running**节点使用的，在实际执行中，会出现图上等待固定时间未执行的情况（核心区别：缺失**Running**节点），其原因是：打断节点，当帧一定会打断后续所有节点的执行，但是下一帧，复合节点没有继续执行而是重新开始执行。（留意上文：**Running**状态才会让复合节点储存执行的个数。）


### 节点中的RUNNING与打断

补充不同节点对于RUNNING和打断的结果的处理，仅供节点运行结果的参考。


一般来说，不胡乱组合配置，不会遇到一些组合情况，如果有需要，建议实地充分测试组合运行结果和执行情况。


## 逻辑示例

（一些基础逻辑的组合）


## 本文参考

+ [OPSIVE: WHAT IS A BEHAVIOR TREE?](https://opsive.com/support/documentation/behavior-designer/what-is-a-behavior-tree/)


## 思考答案参考

+ 思考１：考虑引导机器学习的对于最优评估的评估方式（函数），把高层行为拆分为数据。

+

