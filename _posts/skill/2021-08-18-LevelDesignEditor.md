---
layout: post
title: 好的编辑器的若干特性
featured-img: besiege
mathjax: true
categories: [Unity, Summary]
---

游戏开发中的编辑器，应当具备些什么特性才能更好地为游戏设计师们赋能？让想法表达、工业化、创作作品更为容易。

<!--more-->

# 好的编辑器的若干特性
`jskyzero` `2021/05/25`


## 工具的必要性

> 设计师们设计内容，并借用工具表达设计，输出最终的产物。

通常来看，从业者们会需要一个专业的工具或者软件，用来将想法转变为专业的产物，对于原画师，可能是绘图软件；对于作家，可能是纸币或者写作软件；对于策划，则可能是EXCEL或者特异性的编辑器。

从这个角度理解起来，工具的实用性能很大程度上改善工作的效率，“工欲善其事必先利其器”，而特异性的需求和其编辑器，就像DSL（领域特定语言）和其对应的编辑工具。

对应起来，一个很基础的关于编辑器的问题是：为什么不直接写代码？而要去折腾一个新的编辑器和对应组织数据结构。

这个问题暗示使用C#作为逻辑的描述语言：

+ 借助UNITY引擎内部的MonoBehavior的“生命周期”逻辑，可以原生的访问所有接口。
+ C#作为一门面向对象的高级编程语言的表达能力、架构能力。
+ 使用编程语言的调试灵活度。

似乎直接使用原生语言，可以作为默认的、同时也是极其强大的解决方案。那么为什么我们需要一个领域特定语言来组织逻辑？

很简单，因为

以下施工中


同样的，PlayMaker可以用来组织条件和逻辑操作，也是是逻辑的一种组织方式。

{% mermaid %}
graph LR;
    A[解决方案] -->|包括| B(C# 编写逻辑代码);
    A[解决方案] -->|包括| B1(PlayMaker 编写状态跳转);
{% endmermaid %}

{% mermaid %}
graph LR;
    C{如何评价一种解决方案};
    C -->D[表达能力强];
    D -->D1["接口丰富，可自定义"];
    D -->D2["逻辑组合流转，自由度高"];
    D -->D3["变量，支持使用变量"];
    D -->D4["逻辑条件完备"];
{% endmermaid %}

{% mermaid %}
graph LR;
    C{如何评价一种解决方案};
    C -->E[易维护];
    E -->E1[可读性];
    E -->E2[易学习];
    E -->E0[可复用];
    E -->E3[调试容易];
    E -->E4["易修改，修改可控"];
{% endmermaid %}

{% mermaid %}
graph LR;
    C{如何评价一种解决方案};
    C -->F[设计优雅];
    F -->F1[数理逻辑模型];
    F -->F2[脚本生命周期];
{% endmermaid %}

与C#编写逻辑代码相比，PlayMaker突出的优点

+ 学习成本低：可视化，无需了解编程知识。
+ 可读性好：脱离于代码以外，状态一目了然。
+ 复用性好：无需额外的架构抽象

此外，上面提到的诸多场景也都有对应的一些功能和特性，如支持变量、有丰富的已有库等。

PlayMaker的局限性：

+ 状态机的局限性：
  + 包括复杂度提高以后的易读、修改成本
  + 状态机本身表达能力


## PlayMaker概览

接下里我们具体讨论一下PlayMaker的相关逻辑。

一个例子：

{% mermaid %}
graph TD;
    A[灯是灭的] -->|开灯| B[灯是亮的];
    B -->|关灯| A;

    A1[灯是灭的] -->|包含| D(开灯动作);
    D --> |执行完| D1(关灯完成事件);
    
    B1[灯是亮的]-->|包含| E(关灯动作);
    E --> |执行完| E1(关灯完成事件);
{% endmermaid %}

例子中我们可以看到：

+ 使用状态作为基本组织单位，使用状态机的跳转组织逻辑
  + 状态中包含脚本操作
  + 脚本操作（或者外界行为）触发事件
  + 事件触发状态的跳转

<!-- ### 教程：灯的开关

+ 状态
+ 事件
+ 状态机的跳转
+ 操作：GUI组件（点击）
+ 事件


### 教程：宝箱的开关

+ 过渡状态
+ 操作：动画播放

### 教程：触发器

+ 触发器
+ 触发器脚本，事件
+ 操作：GUI TEXT

### 尝试：自定义脚本

+ 模板
+ 注释 -->


## 关卡与脚本抽象

先鸽了
