<!DOCTYPE html>
<html lang="en">
<!-- <meta http-equiv="Content-Security-Policy" content="default-src 'none'; script-src 'self'; style-src 'self' https://fonts.googleapis.com; img-src 'self'; font-src 'self' https://fonts.gstatic.com; connect-src 'self'; media-src 'self'; object-src 'self'; child-src 'self'; form-action 'none'; base-uri 'self'" /> -->
<!-- <meta http-equiv="Content-Security-Policy" content="script-src 'self' https://cdnjs.cloudflare.com; style-src 'self' https://fonts.googleapis.com; font-src 'self' https://fonts.gstatic.com; connect-src 'self'; media-src 'self'; object-src 'self'; child-src 'self'; form-action 'none'; base-uri 'self'" /> -->
<meta http-equiv="X-XSS-Protection"  content="1;mode=block" always>
<meta http-equiv="Referrer-Policy" content="no-referrer, strict-origin-when-cross-origin"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>拆包看狮子猿AI设计 | 设计者笔记</title><!-- Begin Jekyll SEO tag v2.8.0 -->
<meta name="generator" content="Jekyll v4.2.2" />
<meta property="og:title" content="拆包看狮子猿AI设计" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="之前拆包看了只狼的狮子猿的一阶段动画，本文则会对怪物的AI进行一些讨论和分析，并对之前文章的一些错误结论进行勘误。" />
<meta property="og:description" content="之前拆包看了只狼的狮子猿的一阶段动画，本文则会对怪物的AI进行一些讨论和分析，并对之前文章的一些错误结论进行勘误。" />
<link rel="canonical" href="https://design.jskyzero.com/2023/10/10/sekiro_lion_tamarin_AI/" />
<meta property="og:url" content="https://design.jskyzero.com/2023/10/10/sekiro_lion_tamarin_AI/" />
<meta property="og:site_name" content="设计者笔记" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2023-10-10T00:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="拆包看狮子猿AI设计" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2023-10-10T00:00:00+00:00","datePublished":"2023-10-10T00:00:00+00:00","description":"之前拆包看了只狼的狮子猿的一阶段动画，本文则会对怪物的AI进行一些讨论和分析，并对之前文章的一些错误结论进行勘误。","headline":"拆包看狮子猿AI设计","mainEntityOfPage":{"@type":"WebPage","@id":"https://design.jskyzero.com/2023/10/10/sekiro_lion_tamarin_AI/"},"url":"https://design.jskyzero.com/2023/10/10/sekiro_lion_tamarin_AI/"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" type="text/css" href="/assets/main-light.css"><!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-V2SSPG3YGX"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-V2SSPG3YGX');
</script><!-- high light -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/styles/default.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/highlight.min.js"></script>
</head>
<body>
    <div class="container"><header>
  <div class="menu">
    <ul><li><a href="/">/Home</a></li><li><a href="/program/">/Program</a></li><li><a href="/github/">/Github</a></li><li><a href="/project/">/Project</a></li></ul>
  </div>
</header>
<main>
      <div id="index">
  <ul class="md-toc">
  <li class="md-toc-h1"><a href="#拆包看狮子猿ai设计">拆包看狮子猿AI设计</a>
    <ul>
      <li class="md-toc-h2"><a href="#初步的体验反推">初步的体验反推</a>
        <ul>
          <li class="md-toc-h3"><a href="#交错比例与招式cd">交错比例与招式CD</a></li>
          <li class="md-toc-h3"><a href="#用行为树的简单拟合">用行为树的简单拟合</a></li>
        </ul>
      </li>
      <li class="md-toc-h2"><a href="#基于lua的架构设计">基于LUA的架构设计</a>
        <ul>
          <li class="md-toc-h3"><a href="#决策与逻辑分离">决策与逻辑分离</a></li>
          <li class="md-toc-h3"><a href="#带条件检测的行为队列">带条件检测的行为队列</a></li>
          <li class="md-toc-h3"><a href="#其他架构逻辑">其他架构逻辑</a></li>
        </ul>
      </li>
      <li class="md-toc-h2"><a href="#感受与细节设计">感受与细节设计</a>
        <ul>
          <li class="md-toc-h3"><a href="#主决策逻辑">主决策逻辑</a></li>
          <li class="md-toc-h3"><a href="#行为逻辑">行为逻辑</a></li>
          <li class="md-toc-h3"><a href="#剑戟弹刀逻辑">剑戟（弹刀）逻辑</a></li>
        </ul>
      </li>
      <li class="md-toc-h2"><a href="#总结">总结</a></li>
    </ul>
  </li>
</ul>
  <p id="pro">
  
  <!-- <div class="categories"> -->
    
    
    <img src="https://img.shields.io/badge/动作游戏分析-blue.svg?style=flat" alt="">
    <!--  -->
    
  <!-- </div> -->
  
  <img src="https://img.shields.io/badge/作者-jskyzero-brightgreen.svg?style=flat" alt="">
  <img src="https://img.shields.io/badge/日期-2023/10/10-brightgreen.svg?style=flat" alt="">
</p>

</div>

<p>之前拆包看了<a href="https://design.jskyzero.com/2023/02/17/sekiro_lion_tamarin/">只狼的狮子猿的一阶段动画</a>，本文则会对怪物的AI进行一些讨论和分析，并对之前文章的一些错误结论进行勘误。</p>

<p>本文的目标是以狮子猿一阶段<strong>成熟完备的AI</strong>为例子，让读者能对动作游戏中AI的设计有一个初步的理解，并分析一些对实际工作中设计有启发的逻辑细节。本文会分为三个部分：初步的体验反推、拆包后对主AI分析的架构设计、以及细节和感受分析和讨论。</p>

<h1 id="拆包看狮子猿ai设计">拆包看狮子猿AI设计</h1>

<h2 id="初步的体验反推">初步的体验反推</h2>

<p>首个尝试，和狮子猿录了一段素材，用肉眼将动作与之前的状态机进行匹配，得到了如下的结果：</p>

<p><img src="/assets/img/gameplay/sekiro_lion_tamarion_ai/1.png" alt="" /></p>

<blockquote>
  <p>全程视频可参考：<a href="TODO">Bilibili 笨办法</a></p>
</blockquote>

<p>其中的标注和动画状态机对应如下表所示：</p>

<table>
  <thead>
    <tr>
      <th>标注</th>
      <th>类别</th>
      <th>动画</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>连段1</td>
      <td>花里胡哨类</td>
      <td>3019;3020</td>
    </tr>
    <tr>
      <td>连段2</td>
      <td>花里胡哨类</td>
      <td>3000;3001</td>
    </tr>
    <tr>
      <td>连段2.变种</td>
      <td>花里胡哨类</td>
      <td>3000</td>
    </tr>
    <tr>
      <td>连段3</td>
      <td>花里胡哨类</td>
      <td>3003;3004</td>
    </tr>
    <tr>
      <td>连段4</td>
      <td>花里胡哨类</td>
      <td>3021</td>
    </tr>
    <tr>
      <td>跳跃攻击</td>
      <td>记忆点类</td>
      <td>3014</td>
    </tr>
    <tr>
      <td>红光1</td>
      <td>记忆点类</td>
      <td>3016</td>
    </tr>
    <tr>
      <td>空窗期</td>
      <td>表演类</td>
      <td>四方向闪避位移</td>
    </tr>
    <tr>
      <td>空窗期</td>
      <td>表演类</td>
      <td>原地吼，3018</td>
    </tr>
  </tbody>
</table>

<h3 id="交错比例与招式cd">交错比例与招式CD</h3>

<p>从这个视频中我们可以得出一些初步的结论:</p>

<ul>
  <li>攻击与空隙交错，比例是？</li>
</ul>

<p><img src="/assets/img/gameplay/sekiro_lion_tamarion_ai/2.png" alt="" /></p>

<p>大体上，狮子猿会维持如上图所示【攻击，空窗期】这样的单元重复，以此营造出凶猛进攻和灵动移动结合的交手体验。</p>

<p>其中，攻击的长度观察为1-4个完整招式，而空窗期通常为一次闪避位移。</p>

<ul>
  <li>招式没有复读，CD是？</li>
</ul>

<p><img src="/assets/img/gameplay/sekiro_lion_tamarion_ai/3.png" alt="" /></p>

<p>将招式分别拆开，我们会发现同个招式没有连续两次出现的情况。观察两个招式之间的最短间隔时长（从上一个末尾到下一个的开始）：</p>

<table>
  <thead>
    <tr>
      <th>标注</th>
      <th>最短时间间隔约</th>
      <th>动画</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>连段1</td>
      <td> </td>
      <td>3019;3020</td>
    </tr>
    <tr>
      <td>连段2与变种</td>
      <td>6</td>
      <td>3000;3001</td>
    </tr>
    <tr>
      <td>连段3</td>
      <td> </td>
      <td>3003;3004</td>
    </tr>
    <tr>
      <td>连段4</td>
      <td>6</td>
      <td>3021</td>
    </tr>
    <tr>
      <td>跳跃攻击</td>
      <td>50</td>
      <td>3014</td>
    </tr>
    <tr>
      <td>红光1</td>
      <td>9</td>
      <td>3016</td>
    </tr>
    <tr>
      <td>空窗期</td>
      <td>5</td>
      <td>四方向闪避位移</td>
    </tr>
  </tbody>
</table>

<h3 id="用行为树的简单拟合">用行为树的简单拟合</h3>

<p>总结一些关键结论：</p>

<ol>
  <li>攻击行为与空窗期相间</li>
  <li>攻击行为自身有间隔</li>
</ol>

<p>我们可以使用行为树对这个<code class="language-plaintext highlighter-rouge">出招序列</code>进行一个简单的拟合：</p>

<p><img src="/assets/img/gameplay/sekiro_lion_tamarion_ai/4.png" alt="" /></p>

<p>这个决策逻辑逻辑看起来很简单，因为这段战斗也只是一个局部序列，有着一定的局限性，不过还是做一个思考练习，如何让这个逻辑变得更好？</p>

<ul>
  <li>与战斗进程挂钩的空窗间隔</li>
</ul>

<p>简单来说，通过<strong>控制空窗期的CD来控制玩家的战斗压力</strong>，结合一个能反映玩家战斗进程的数值——比如血量或者时间，就可以形成差异化的心流体验或者战斗历程。</p>

<ul>
  <li>更加复杂且细致的条件</li>
</ul>

<p>和上面的思路类似，我们可以<strong>为不同的技能设置除了CD以外更加细致的条件</strong>，比如关联自身血量，对于只狼来说，基础重要属性还有自身的架势槽；对于一个常规的动作游戏，还可以关联敌我的空间位置关系等条件。</p>

<ul>
  <li>攻击前的调整位置</li>
</ul>

<p>对于一个动作游戏，招式的适用打击距离，一般是有限的。比如一个前冲拳，能冲的距离可能最多4米，那么对于4米外的目标，可能就<strong>需要先靠近目标再释放</strong>，不然就会形成空挥的体验（当然，空挥也是一种体验！）。对于4米内过近的目标，可能也需要先远离，避免一些不好的表现。</p>

<p>这部分可以通过设置招式前的距离检测来避免。这些检测相应的也会造成限制从而降低释放的可能性，这是一个取舍问题。</p>

<ul>
  <li>小结</li>
</ul>

<p>以传统而经典的行为树配置方法的话，对狮子猿AI的分析大致如上所述。当然，文章的长度已经出卖了作者，下文才是本次分析的重点，但是上文所叙述一些经典分析方法乃至思路也是相当重要的。</p>

<p>那么话不多说，我们来看看拆包/反编译后的狮子猿AI的LUA脚本。</p>

<h2 id="基于lua的架构设计">基于LUA的架构设计</h2>

<p>接下来我们讨论一些架构相关的话题，有时会使用行为树来对比。</p>

<h3 id="决策与逻辑分离">决策与逻辑分离</h3>

<p>拆包后的lua文件大致如下所示：</p>

<p><img src="/assets/img/gameplay/sekiro_lion_tamarion_ai/5.png" alt="" /></p>

<blockquote>
  <p>原始内容可以参考：<a href="/assets/img/gameplay/sekiro_lion_tamarion_ai/510000_battle.dec.lua">狮子猿 510000_battle.dec.lua</a>，后文部分内容涉及到<a href="/assets/img/gameplay/sekiro_lion_tamarion_ai/509000_battle.dec.lua">蝴蝶夫人 509000_battle.dec.lua</a></p>
</blockquote>

<p>最外层是若干函数，如下图所示这里将其分了四类，具体的逻辑我们将在第三部分展开叙述。</p>

<p><img src="/assets/img/gameplay/sekiro_lion_tamarion_ai/6.png" alt="" /></p>

<p>和传统的行为树比，有一个非常具体的区别，只狼（或者说FromSoftware的游戏）的AI是将主决策逻辑和行为逻辑分开的。比如上图所示的<code class="language-plaintext highlighter-rouge">Activate</code>函数里面是主决策逻辑，里面会在一定条件下调用不同的<code class="language-plaintext highlighter-rouge">ActXX</code>系列函数。</p>

<p>这样做有什么好处呢？我认为是<strong>高效复用</strong>和<strong>分离逻辑</strong>。</p>

<h4 id="高效复用">高效复用</h4>

<p>先从高效复用说起，在行为树的语境里，如果<strong>在两个地方都需要同一段逻辑</strong>，最简单的方法是直接拷贝一串逻辑过去，这样会很简单，但是问题就是，下次修改时，容易遗漏，或者出其他差错。</p>

<p>相对完善的方法是，<strong>编写一个AI子树</strong>，去定义一些传递的黑板变量，但是这个操作的成本就会变高，普遍需要管理独立的新文件，增加心智上的负担。</p>

<p>而使用脚本语言，则可以利用编程语言自带的函数的语法，来高效实现这一过程。（这里并不是说使用LUA脚本，就比行为树要好，只是各自有不同的特点。）</p>

<p><img src="/assets/img/gameplay/sekiro_lion_tamarion_ai/7.png" alt="" /></p>

<h4 id="分离逻辑">分离逻辑</h4>

<p>另一个话题则是分离逻辑，如果你配置过复杂AI的话，应该能理解<strong>AI设计的核心问题之一，就是解决复杂度的问题</strong>，这需要工程学的方法、可扩展且表达力强的通用架构、编写时符合直觉的逻辑思路等等……</p>

<p><strong>将问题划分、以大化小的分治法</strong>也是核心思路之一，将行为逻辑和决策逻辑分开，能让双方聚焦各自的问题：决策逻辑负责复杂的条件检测，调用行为；而行为逻辑则只解决一个具体行为的实现，这里也可能会有一定的条件检测。但是是服务于这个行为的。这样，在面对复杂逻辑时，就可以将复杂逻辑化为若干部分，分别实现，避免干扰。</p>

<p><img src="/assets/img/gameplay/sekiro_lion_tamarion_ai/8.png" alt="" /></p>

<blockquote>
  <p>一个类似思路的、在软件工程的语境的例子是<a href="https://developer.mozilla.org/en-US/docs/Glossary/MVC">MVC架构（Model-View-Controller，模型-视图-控制器）</a>。将软件分为：数据描述相关、处理交互视图相关、处理如何控制数据相关，三个部分各司其职，避免互相干涉带来的心智负担。</p>
</blockquote>

<h3 id="带条件检测的行为队列">带条件检测的行为队列</h3>

<p>本小节我们聚焦到一个具体的行为的架构设计。比如【靠近，A招式，B招式】的一个行动序列。</p>

<p>在行为树的语境中，会使用运行节点来描述一个耗时的行为，大概会如下图所示去实现：</p>

<p><img src="/assets/img/gameplay/sekiro_lion_tamarion_ai/9.png" alt="" /></p>

<p>想象一下这样的命令在Lua的一个函数中应该怎样描述实现？对于单个命令，下达单个的命令指令就行，但是当涉及到一连串连续执行的命令，就会麻烦一些。</p>

<h4 id="行为队列">行为队列</h4>

<p>答案是维护一个行为的“队列”，对于【靠近，A招式，B招式】这个序列，就添加靠近，A招式，B招式三个命令，等到执行的时候按照队列的先进先出的顺序挨个执行。</p>

<div class="language-lua highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">arg1</span><span class="p">:</span><span class="n">AddSubGoal</span><span class="p">(</span><span class="n">GOAL_COMMON_ApproachTarget</span><span class="p">,</span> <span class="n">f3_local4</span><span class="p">,</span> <span class="n">TARGET_ENE_0</span><span class="p">,</span> <span class="n">f3_local1</span><span class="p">,</span> <span class="n">TARGET_SELF</span><span class="p">,</span> <span class="n">f3_local3</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="n">arg1</span><span class="p">:</span><span class="n">AddSubGoal</span><span class="p">(</span><span class="n">GOAL_COMMON_ComboTunable_SuccessAngle180</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">f3_local5</span><span class="p">,</span> <span class="n">TARGET_ENE_0</span><span class="p">,</span> <span class="mi">999</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">arg1</span><span class="p">:</span><span class="n">AddSubGoal</span><span class="p">(</span><span class="n">GOAL_COMMON_ComboRepeat_SuccessAngle180</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">f3_local6</span><span class="p">,</span> <span class="n">TARGET_ENE_0</span><span class="p">,</span> <span class="mi">999</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</code></pre></div></div>

<p>类似下图，这是Act01行为的<strong>两个攻击的添加命令的代码</strong>和<strong>开发者工具观察实际执行的Goal队列</strong></p>

<p><img src="/assets/img/gameplay/sekiro_lion_tamarion_ai/10.png" alt="" /></p>

<p>可以观察到，添加命令（或者，行动目标，这里维持统一还是使用命令这个词）时候，有非常多的参数，除了常规描述行为是啥的自身关键参数，还有一个时间参数。主要是用于避免操控的对象一致处于某个行为中，给个超时。</p>

<blockquote>
  <p>在只狼的架构中，这个时间在自己执行的时候才会开始倒数，还有一种做法是，在添加入执行队列就开始倒数，应该也是一种规则。</p>
</blockquote>

<h4 id="条件检测的时效性">条件检测的时效性</h4>

<p>找了一个移动和释放攻击的命令的指令，大概对应的一下参数的含义，如下图所示。</p>

<p><img src="/assets/img/gameplay/sekiro_lion_tamarion_ai/11.png" alt="" /></p>

<ul>
  <li>对于移动来说，当达到距离时则视为成功，这里是用作判断持续行为的成功结束条件。</li>
  <li>而对于释放攻击老说，如果不满足释放距离则会释放失败，这里是用作开始执行的前置条件。</li>
</ul>

<p>留意<strong>开始执行的前置条件</strong>，在添加命令的时候就可以进行一次检测，那为什么不在添加命令的时候就进行检测呢？对比下面这两个例子：</p>

<ul>
  <li>添加指令时检测距离</li>
</ul>

<div class="language-lua highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- 添加指令时检测距离</span>
<span class="n">AddGoal_BlaBla</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">9999</span><span class="p">)</span> <span class="c1">-- 添加释放攻击动作1、时间10秒、释放前检测9999米</span>
<span class="k">if</span> <span class="n">L</span> <span class="o">&lt;</span> <span class="mi">5</span> <span class="k">then</span> <span class="c1">-- 判断距离小于5米</span>
    <span class="n">AddGoal_BlaBla</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">9999</span><span class="p">)</span> <span class="c1">-- 添加释放攻击动作2、时间10秒、释放前检测9999米</span>
<span class="k">end</span>
</code></pre></div></div>

<ul>
  <li>指令执行时检测距离</li>
</ul>

<div class="language-lua highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- 指令执行时检测距离</span>
<span class="n">AddGoal_BlaBla</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">9999</span><span class="p">)</span> <span class="c1">-- 添加释放攻击动作1、时间10秒、释放前检测9999米</span>
<span class="n">AddGoal_BlaBla</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="c1">-- 添加释放攻击动作2、时间10秒、释放前检测5米内</span>
</code></pre></div></div>

<p>其实标注已经暴露了核心问题，添加指令时和指令执行时，可能不是同一时刻，而这个单独的检测选项就是解决这个问题，<strong>确保能在指令执行时，进行检测。</strong></p>

<p>听起来有点像打补丁的做法，解决的核心问题是：决策进行的瞬间，一次性可能添加了很多动作序列；序列靠后被执行的单个动作，轮到这个它的时候，前置条件已经失去了意义。</p>

<p>在行为树的语境中其实不存在这个问题，运行节点会完美过渡时间，轮到这个节点执行前才会真的进行这个节点的检测，但也可能，就是因为这种模糊性，会带来类似“空挥”的体验，这里不再展开讨论了。</p>

<h3 id="其他架构逻辑">其他架构逻辑</h3>

<p>这里讨论一些其他的、用于逻辑表达的小设计。</p>

<h4 id="行为概率与行为cd">行为概率与行为CD</h4>

<p>前面我们提到过，由决策逻辑调用行动逻辑的函数：</p>

<p><img src="/assets/img/gameplay/sekiro_lion_tamarion_ai/13.png" alt="" /></p>

<p>但是这个过程还是挺有意思的，并没有直接去调用函数，而是使用概率做中转，再去调用对应的函数。</p>

<div class="language-lua highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- 首先整了几个“表格”做中转</span>
<span class="kd">local</span> <span class="n">f2_local0</span> <span class="o">=</span> <span class="p">{}</span>
<span class="kd">local</span> <span class="n">f2_local1</span> <span class="o">=</span> <span class="p">{}</span>
<span class="kd">local</span> <span class="n">f2_local2</span> <span class="o">=</span> <span class="p">{}</span>

<span class="c1">-- 当决策的时候，</span>
<span class="c1">-- 将X号行为的发生概率储存到，0号表格，Key为X的值里</span>
<span class="k">if</span> <span class="n">f2_local5</span> <span class="o">&gt;=</span> <span class="mi">18</span> <span class="k">then</span>
    <span class="n">f2_local0</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="mi">50</span>
    <span class="n">f2_local0</span><span class="p">[</span><span class="mi">15</span><span class="p">]</span> <span class="o">=</span> <span class="mi">800</span>
    <span class="n">f2_local0</span><span class="p">[</span><span class="mi">18</span><span class="p">]</span> <span class="o">=</span> <span class="mi">50</span>
    <span class="n">f2_local0</span><span class="p">[</span><span class="mi">19</span><span class="p">]</span> <span class="o">=</span> <span class="mi">50</span>
    <span class="n">f2_local0</span><span class="p">[</span><span class="mi">43</span><span class="p">]</span> <span class="o">=</span> <span class="mi">100</span>
<span class="k">elseif</span> <span class="n">f2_local5</span> <span class="o">&gt;=</span> <span class="mi">12</span> <span class="k">then</span>
<span class="c1">-- ...</span>
<span class="k">elseif</span> <span class="n">f2_local5</span> <span class="o">&gt;=</span> <span class="mi">5</span> <span class="k">then</span>
<span class="c1">-- ...</span>
<span class="k">end</span>

<span class="c1">-- 检查冷却，如果不满足，概率直接打到1</span>
<span class="n">f2_local0</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">SetCoolTime</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="mi">3000</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="n">f2_local0</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">f2_local0</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">SetCoolTime</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="mi">3003</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="n">f2_local0</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
<span class="c1">-- ...</span>
<span class="n">f2_local0</span><span class="p">[</span><span class="mi">46</span><span class="p">]</span> <span class="o">=</span> <span class="n">SetCoolTime</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="mi">3005</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">f2_local0</span><span class="p">[</span><span class="mi">46</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>

<span class="c1">-- 将X号行为的函数储存到，1号表格，Key为X的值里</span>
<span class="n">f2_local1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">REGIST_FUNC</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="n">arg0</span><span class="p">.</span><span class="n">Act01</span><span class="p">)</span>
<span class="n">f2_local1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">REGIST_FUNC</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="n">arg0</span><span class="p">.</span><span class="n">Act02</span><span class="p">)</span>
<span class="c1">-- ...</span>
<span class="n">f2_local1</span><span class="p">[</span><span class="mi">48</span><span class="p">]</span> <span class="o">=</span> <span class="n">REGIST_FUNC</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="n">arg0</span><span class="p">.</span><span class="n">Act48</span><span class="p">)</span>

<span class="c1">-- 最后调用，根据0号表格的概率调用 1号表格储存的函数行为</span>
<span class="c1">-- 此处函数完整内容可参考</span>
<span class="c1">-- aicommon-luabnd-dcx\script\ai\out\bin\common_battle_func.dec.lua</span>
<span class="n">Common_Battle_Activate</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="n">f2_local0</span><span class="p">,</span> <span class="n">f2_local1</span><span class="p">,</span> <span class="n">f2_local13</span><span class="p">,</span> <span class="n">f2_local2</span><span class="p">)</span>
</code></pre></div></div>

<p>如果上面的内容稍微有点复杂，没关系，举个具体的例子：</p>

<p><img src="/assets/img/gameplay/sekiro_lion_tamarion_ai/14.png" alt="" /></p>

<p>在某个情形下，如果我们决定使用Act01和Act02行为，且概率为100:50，那么我们<strong>并不会直接进行随机数的比较后调用函数</strong>，而是会将概率储存下来，同时将行为也储存下来，两者维持下标相同。这样脱钩后，甚至还可以进行一次CD的检测，如果不满足CD，则可以直接将概率打到最小，（为1不为0也处理了所有行为都CD时，至少可以随机出结果。）最后，再根据概率去调用对应的行为。</p>

<p>这样做的好处是显而易见的，它允许我们<strong>将可用性检测——比如CD或者其他规则，放在决策之后</strong>，一方面保证了可用性的筛选，另一方面也避免了先进行可用性检测的麻烦，甚至概率为1而不为0的小细节，也覆盖了全部行为都在CD的边界情况。</p>

<blockquote>
  <p>在行为树的语境中，先进行可用性检测可以使用封装了自规划的算法的节点，选取可用性最高的行为。</p>

  <p>在实际的工作中，有时没有规划算法的节点，最常见的情形和解决是，检测到攻击仍然处于CD，干脆失败向后决策，用发呆来作为保底。</p>
</blockquote>

<h4 id="信息感知与标记buff">信息感知与标记BUFF</h4>

<p>对于一个动作游戏的AI，除了常规的HP、MP、位置等信息，对于敌我<strong>动作状态</strong>的检测逻辑应该会很多，动作游戏嘛，玩的就是动作之间的规则。</p>

<p>只狼也不例外，一些信息的获取、判断如下所示：</p>

<div class="language-lua highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- Goal.Activate 局部变量</span>
<span class="kd">local</span> <span class="n">f2_local3</span> <span class="o">=</span> <span class="n">arg1</span><span class="p">:</span><span class="n">GetHpRate</span><span class="p">(</span><span class="n">TARGET_SELF</span><span class="p">)</span>
<span class="kd">local</span> <span class="n">f2_local4</span> <span class="o">=</span> <span class="n">arg1</span><span class="p">:</span><span class="n">GetSpRate</span><span class="p">(</span><span class="n">TARGET_SELF</span><span class="p">)</span>
<span class="kd">local</span> <span class="n">f2_local5</span> <span class="o">=</span> <span class="n">arg1</span><span class="p">:</span><span class="n">GetDist</span><span class="p">(</span><span class="n">TARGET_ENE_0</span><span class="p">)</span>
<span class="kd">local</span> <span class="n">f2_local6</span> <span class="o">=</span> <span class="n">arg1</span><span class="p">:</span><span class="n">GetRandam_Int</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="kd">local</span> <span class="n">f2_local7</span> <span class="o">=</span> <span class="n">arg1</span><span class="p">:</span><span class="n">GetExcelParam</span><span class="p">(</span><span class="n">AI_EXCEL_THINK_PARAM_TYPE__thinkAttr_doAdmirer</span><span class="p">)</span>
<span class="kd">local</span> <span class="n">f2_local8</span> <span class="o">=</span> <span class="n">arg1</span><span class="p">:</span><span class="n">GetEventRequest</span><span class="p">()</span>
<span class="kd">local</span> <span class="n">f2_local9</span> <span class="o">=</span> <span class="n">arg1</span><span class="p">:</span><span class="n">GetEventRequest</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="kd">local</span> <span class="n">f2_local10</span> <span class="o">=</span> <span class="n">arg1</span><span class="p">:</span><span class="n">GetDistY</span><span class="p">(</span><span class="n">TARGET_SELF</span><span class="p">)</span>
<span class="kd">local</span> <span class="n">f2_local11</span> <span class="o">=</span> <span class="n">arg1</span><span class="p">:</span><span class="n">GetDistY</span><span class="p">(</span><span class="n">TARGET_ENE_0</span><span class="p">)</span>
<span class="kd">local</span> <span class="n">f2_local12</span> <span class="o">=</span> <span class="n">arg1</span><span class="p">:</span><span class="n">HasSpecialEffectId</span><span class="p">(</span><span class="n">TARGET_SELF</span><span class="p">,</span> <span class="mi">200050</span><span class="p">)</span>
<span class="c1">-- Goal.Activate 变量检测</span>
<span class="k">elseif</span> <span class="ow">not</span> <span class="ow">not</span> <span class="n">arg1</span><span class="p">:</span><span class="n">HasSpecialEffectId</span><span class="p">(</span><span class="n">TARGET_ENE_0</span><span class="p">,</span> <span class="mi">110060</span><span class="p">)</span> <span class="ow">or</span> <span class="n">arg1</span><span class="p">:</span><span class="n">HasSpecialEffectId</span><span class="p">(</span><span class="n">TARGET_ENE_0</span><span class="p">,</span> <span class="mi">110010</span><span class="p">)</span> <span class="k">then</span>
        <span class="n">f2_local0</span><span class="p">[</span><span class="mi">39</span><span class="p">]</span> <span class="o">=</span> <span class="mi">100</span>
<span class="k">elseif</span> <span class="n">Common_ActivateAct</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">)</span> <span class="k">then</span>
</code></pre></div></div>

<p>总结归纳一下，常规的信息大致包括这些：</p>

<ul>
  <li>属性类
    <ul>
      <li>HP</li>
      <li>SP</li>
      <li>固有Excel变量</li>
    </ul>
  </li>
  <li>空间类
    <ul>
      <li>敌我距离</li>
      <li>距地面高度</li>
      <li>敌我角度</li>
      <li>障碍物检测</li>
    </ul>
  </li>
  <li>随机类
    <ul>
      <li>随机整数</li>
      <li>随机小数</li>
    </ul>
  </li>
</ul>

<p>而关于动作的检测，除了一些经过封装的函数或者事件，大部分都是用标记BUFF实现的。</p>

<p>一个很典型的例子是蝴蝶夫人的弹反动作，左方向8400，右方向8401，分别添加了200211和200210，两个不同的标记异常状态，这样AI就可以通过检测对于的标记buff，来知道是蝴蝶夫人是在左弹还是右弹。</p>

<p><img src="/assets/img/gameplay/sekiro_lion_tamarion_ai/12.png" alt="" /></p>

<p>再进一步，可以根据左右弹设计不同的出招逻辑：</p>

<div class="language-lua highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- 509000 蝴蝶夫人</span>
<span class="c1">-- Goal.Kengeki_Activate 逻辑判断</span>
    <span class="k">elseif</span> <span class="n">f48_local0</span> <span class="o">==</span> <span class="mi">200210</span> <span class="k">then</span>
        <span class="k">if</span> <span class="n">f48_local4</span> <span class="o">&gt;=</span> <span class="mi">4</span> <span class="k">then</span>
            <span class="n">f48_local1</span><span class="p">[</span><span class="mi">50</span><span class="p">]</span> <span class="o">=</span> <span class="mi">100</span>
        <span class="k">elseif</span> <span class="n">SpaceCheck</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="mi">180</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="o">==</span> <span class="kc">false</span> <span class="k">then</span>
            <span class="n">f48_local1</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="mi">20</span>
            <span class="n">f48_local1</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="mi">80</span>
        <span class="k">else</span>
            <span class="n">f48_local1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">15</span>
            <span class="n">f48_local1</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="o">=</span> <span class="mi">15</span>
            <span class="n">f48_local1</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="mi">100</span>
        <span class="k">end</span>
    <span class="k">elseif</span> <span class="n">f48_local0</span> <span class="o">==</span> <span class="mi">200211</span> <span class="k">then</span>
        <span class="k">if</span> <span class="n">f48_local4</span> <span class="o">&gt;=</span> <span class="mi">4</span> <span class="k">then</span>
            <span class="n">f48_local1</span><span class="p">[</span><span class="mi">50</span><span class="p">]</span> <span class="o">=</span> <span class="mi">100</span>
        <span class="k">elseif</span> <span class="n">SpaceCheck</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="mi">180</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="o">==</span> <span class="kc">false</span> <span class="k">then</span>
            <span class="n">f48_local1</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="mi">40</span>
            <span class="n">f48_local1</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="mi">60</span>
        <span class="k">else</span>
            <span class="n">f48_local1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">40</span>
            <span class="n">f48_local1</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="o">=</span> <span class="mi">20</span>
            <span class="n">f48_local1</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="mi">60</span>
        <span class="k">end</span>
</code></pre></div></div>

<p>猜测接口上，除了自己给自己加标记buff，应该也是可以定向给敌人加的。</p>

<p>小结一下：以标记buff作为检测动作的中间层，可以一定程度上让逻辑与具体的Action检测脱钩，避免AI与动作的强耦合，带来修改时的麻烦。但是也会需要buff自身是一个简单易用、高效的功能。</p>

<h4 id="计时器角色变量事件与打断">计时器/角色变量/事件与打断</h4>

<p>这里是发现到的一些适用于逻辑编写的功能。</p>

<ul>
  <li>计时器</li>
</ul>

<p>上文提到CD其实也是一种计时器，有些时候如果要控制指定逻辑出现的间隔，就可以使用计时器，大概有以下功能：</p>

<div class="language-lua highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- 开始计时，参数1是记时器的编号，参数2是计时器的倒计时时间</span>
<span class="n">arg0</span><span class="p">:</span><span class="n">SetTimer</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
<span class="c1">-- 比较指定计时器的现在的记时</span>
<span class="n">arg1</span><span class="p">:</span><span class="n">GetTimer</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
<span class="c1">-- 检测指定计时器的记时是否结束</span>
<span class="n">arg1</span><span class="p">:</span><span class="n">IsFinishTimer</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="kc">true</span>
</code></pre></div></div>

<p>只狼的计时器大概是只有16个，事实上也足够了。</p>

<ul>
  <li>角色变量</li>
</ul>

<p>使用角色变量可以方便的在不同逻辑之前储存信息、检查信息：</p>

<div class="language-lua highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- 设置指定变量到指定值</span>
<span class="n">arg1</span><span class="p">:</span><span class="n">SetNumber</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="c1">-- 设置指定变量自增</span>
<span class="n">arg1</span><span class="p">:</span><span class="n">SetNumber</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">arg1</span><span class="p">:</span><span class="n">GetNumber</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="c1">-- 检测指定变量的值</span>
<span class="n">arg1</span><span class="p">:</span><span class="n">GetNumber</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
</code></pre></div></div>

<p>之前在哪里看到过好像4号变量和弹刀有关，记不清了，可见有些变量应该是全角色通用、有统一含义的。</p>

<p>变量的槽位好像也是16个，和计时器一样，固定数目一方面一般不会达到上限，另一方面也可以保证实现起来较为简单、性能开销较为可控。16这个数值感觉是个可参考值。</p>

<ul>
  <li>事件与打断</li>
</ul>

<p>严格意义上感觉不能叫事件，或者叫监听？当发生一些事件时，就会打断原有决策，重新进行打断决策。</p>

<div class="language-lua highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- 添加区域监听</span>
<span class="n">arg0</span><span class="p">:</span><span class="n">AddObserveArea</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">TARGET_SELF</span><span class="p">,</span> <span class="n">TARGET_ENE_0</span><span class="p">,</span> <span class="n">AI_DIR_TYPE_F</span><span class="p">,</span> <span class="mi">360</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
<span class="c1">-- 删除区域监听</span>
<span class="n">arg1</span><span class="p">:</span><span class="n">DeleteObserve</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="c1">-- 判断打断类型：在区域外打断</span>
<span class="n">arg1</span><span class="p">:</span><span class="n">IsInterupt</span><span class="p">(</span><span class="n">INTERUPT_Outside_ObserveArea</span><span class="p">)</span>

<span class="c1">-- 添加Buff监听</span>
<span class="n">arg1</span><span class="p">:</span><span class="n">AddObserveSpecialEffectAttribute</span><span class="p">(</span><span class="n">TARGET_SELF</span><span class="p">,</span> <span class="mi">5025</span><span class="p">)</span>
<span class="c1">-- 判断打断Buff类型</span>
<span class="n">arg1</span><span class="p">:</span><span class="n">GetSpecialEffectActivateInterruptType</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">5039</span>

<span class="c1">-- 处理打断</span>
<span class="n">Goal</span><span class="p">.</span><span class="n">Interrupt</span> <span class="o">=</span> <span class="k">function</span> <span class="p">(</span><span class="n">arg0</span><span class="p">,</span> <span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">)</span>
    <span class="c1">-- ...</span>
    <span class="c1">-- 打断后检测使用道具！药检.jpeg</span>
    <span class="k">if</span> <span class="n">Interupt_Use_Item</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span> <span class="k">then</span>
        <span class="n">arg1</span><span class="p">:</span><span class="n">Replanning</span><span class="p">()</span>
        <span class="k">return</span> <span class="kc">true</span>
    <span class="k">end</span>
    <span class="c1">-- ...</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在打断的逻辑里面看到了使用道具，难道药检的逻辑也在这里？</p>

<p>事件与打断为AI提供了一种针对环境的变化快速反应的能力——反应性，合理使用这部分机制，可以让AI更加生动。但这部分逻辑如果过于“单薄”，也会很容易被玩家利用。</p>

<h4 id="封装">封装</h4>

<p>封装也是</p>

<h2 id="感受与细节设计">感受与细节设计</h2>

<h3 id="主决策逻辑">主决策逻辑</h3>

<h3 id="行为逻辑">行为逻辑</h3>

<h3 id="剑戟弹刀逻辑">剑戟（弹刀）逻辑</h3>

<h2 id="总结">总结</h2>




<pre class="post-content controls__inner git-log"><output>~: git log
31 Oct 2023 - jskyzero - 📝 almost finish 其他架构逻辑
30 Oct 2023 - jskyzero - 📝 add 行为队列 & 条件检测
29 Oct 2023 - jskyzero - 📝 update main structure
27 Oct 2023 - jskyzero - add 初步的体验反推
26 Oct 2023 - jskyzero - 📝 update 拆包看狮子猿AI设计
10 Oct 2023 - jskyzero - add 拆包看狮子猿AI设计

<img alt="Creative Commons License" src="/assets/img/CC.png" />

This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0 License</a>.
</output></pre>


<script src="/assets/js/main.js"></script>
<div id="disqus_thread"></div>
<script>

var disqus_config = function () {
this.page.url = 'https://design.jskyzero.com/2023/10/10/sekiro_lion_tamarin_AI/';
this.page.identifier = 'https://design.jskyzero.com/2023/10/10/sekiro_lion_tamarin_AI/';
};

(function() {
var d = document, s = d.createElement('script');
s.src = 'https://designer-notes.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the comments.</noscript>


    </main><footer>
  <p>Enjoy :)</p>
  <img src="https://img.shields.io/github/last-commit/jskyzero/design.jskyzero.com">
  <img style="border-radius: 4px;"
  src="https://hits.dwyl.com/jskyzero/designjskyzerocom.svg?style=flat-square">
  <br>
  <p>&copy; 2017-2023 设计者笔记. All rights reserved.</p>
  
</footer>
</div>
  </body>
</html>
